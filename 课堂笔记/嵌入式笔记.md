# 嵌入式





## Chapter2 ARM微处理器概述与编程模型

### 基本概念

1. 精简指令集(RISC)与复杂指令集(CISC)，*非重点*

2. 哈佛结构与冯诺依曼结构

![image-20230412192533688](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230412192533688.png)

![image-20230412192551872](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230412192551872.png)

其中，这两种结构与指令系统并无绝对的关联。

3. CPU流水线，精简指令集架构CPU基本都包含流水线设计。
3. ARM采用RISC，因此，其访存方式基本只包含LOAD/STORE指令，简化了微指令数据流![image-20230626121805454](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230626121805454.png)



### ARM处理器的运行模式

<img src="https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230412193544024.png">

除用户模式以外，**其他六种模式被称为特权模式。**

在特权模式之中，程序可以访问所有系统资源；可以切换任意处理器模式。

在用户模式之中，应用程序无法访问被保护的系统资源，不能直接切换到其他模式。*但是可以通过制造异常，调用中断程序，来实现模式切换。*大多数程序运行在用户模式之中。







### ARM处理器的工作状态

1. ARM微处理器的工作状态分以下两种

+ ARM状态：执行32位字对齐的ARM指令
+ Thumb状态：执行16位半字对其的Thumb指令

2. 状态切换

+ **当寄存器Rm的状态位`bit[0] = 1`时**，可以通过执行`BX Rm`指令，使微处理器从ARM状态切换到Thumb状态。

```assembly
code32
ldr r0,=label+1		;地址的最低为1，表示切换到Thumb状态
bx r0

code16
label:
	mov r1,#12
```





### ARM处理器之中的寄存器

在ARM状态下，寄存器共有37个，而thumb状态下，寄存器有27个。

其中包括31个通用寄存器与6个32位状态寄存器。

其中，寄存器的分类如下：

1. 未分组寄存器：R0~R7，所有工作模式下通用
2. 分组寄存器：R8~R12，快速中断fiq模式一种，其他一种

![image-20230503213239883](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230503213239883.png)

3. 分组寄存器：R13与R14，每个模式各一种。

![image-20230503213320986](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230503213320986.png)

在ARM指令集中，通常**使用R13作为堆栈指针SP，R14用于存放指令地址备份寄存器，又称为LR，在执行子程序调用指令时，会拷贝R15之中的数据；R15作为程序计数器PC。**

4.   状态寄存器

     1.   Current Program Status Register，当前程序状态寄存器。所有模式下都指向相同的物理寄存器。

     2.   备份程序状态寄存器（Saved Program Status Register）：每种异常模式都有自己的专用寄存器。异常发生时，保存CPSR；异常退出时，恢复CPSR。

          ![image-20230626122927799](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230626122927799.png)

     3.   CPSR寄存器格式，可能给出寄存器格式以及其中内容，判断当前CPU所处的状态![image-20230626123012255](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230626123012255.png)

**注意：**

1. 当产生中断嵌套时，由于会覆盖掉R14之中存放的程序返回地址，会导致无法正确返回终端调用程序。
2. 程序计数器PC，也就是R15，PC的数值，存放于高30位，而在Thumb状态下，存放于高31位。==其数值等于*当前指令指令地址+8*，因为ARM采用了多级流水线技术。==
3. 每种模式都具备相应的R13寄存器，在进入该模式之前，需要对R13进行初始化。



### ARM处理器之中的虚存-物理地址转换

-   CP15--系统控制协处理器
    -   包含16个32为寄存器
    -   用于对MMU进行配置，完成存储器系统管理
-   ARM内存管理
    -   定义：一些段、大页或者小页的集合
    -   ARM920T支持最大16个域，每个域的访问控制特性由CP15中的C3的两位来控制
        -   0b00:没有访问权限
        -   0b01：客户类型
        -   0b10：保留，使用该值会产生不可预知的效果
        -   0b11：管理者权限

    -   存储访问失效
        -   MMU可以产生4种类型的存储访问失效
            -   地址对齐失效
            -   地址变换失效
            -   域控制失效
            -   访问权限控制失效

        -   当发生访存失效时，存储系统可以终端3种存储访问
            -   Cacha内容预取
            -   非缓冲的存储器访问失效
            -   页表访问


ARM处理器使用快表TLB技术

-   虚拟地址向物理地址转换的过程，其中，CP15中C2寄存器高18位存储了一级页表L1的及地址。

![image-20230624151558505](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230624151558505.png)

-   虚拟地址的结构：

    ![image-20230624151628235](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230624151628235.png)

-   地址转化过程

    -   段方式仅仅需要一次转换：1. 使用C2中高18位+虚拟地址高12位查表获得一级页表表项地址。2. 一级页表表象地址中高12位产生物理地址中的段基地址，加上虚拟地址中的低20位，构成物理地址。
    -   粗页表转换方式：需要两次地址转换。1. 在L1页表中查找粗页表偏移地址。 2. 根据粗页表项中根据粗页表二级页表基地址、二级页表偏移量查找页内地址。 3. 找到页内项之后，再根据小页及地址+虚拟地址中的小页偏移量转换成为物理地址。
    -   细页表转换方式与之同理。

    地址转化具备以下特点：

    -   根据不同的转换方式，将虚拟地址划分为以下几项：1. 一级页表偏移地址 2. 二级页表偏移地址 3. 页内偏移地址。其中，每一项的长度决定了表的长度。
    -   首先根据CP15协处理器之中的C2寄存器，查找一级页表基地址，根据虚拟地址查找对应表表项。
    -   查找到表项之后，判断地址访问方式。01为粗页表方式，10为段方式，11为细页表方式。
    -   根据地址访问控制码，取得相应的二级页表基地址，加上虚拟地址中的偏移地址获得相应的小页表项。
    -   再继续根据细页表进行查找，获得相应的极小页基地址，获得物理地址。

-   禁止与使能MMU

    -   使能MMU：C1寄存器中的位[0]用于设置禁止MMU

        -   C1[0] == 0 时，禁止MMU
        -   C1[1] == 1 时，使能MMU
        -   使能MMU之前，要在主存之中建立页表，同时完成CP15相关寄存器的初始化。

    -   实现使能MMU的汇编指令

        ```assembly
        MRC P15,0,R0,C1,C0,0		;将C1的内容赋给R0
        ORR R0,R0,#0x1				;将最低为设置为1
        MCR P15,0,R0,C1,C0,0		;将R0的内容赋给C1
        ```

    -   禁止MMU

        -   虚拟地址 == 物理地址——平板地址映射。
        -   没有存储访问权限控制，MMU也不会产生异常信号
        -   是否支持Cache与写缓冲有具体芯片决定

        

### ARM异常处理
-   异常优先级

    ![image-20230624174200142](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230624174200142.png)

-   异常类型

    ![image-20230624174918377](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230624174918377.png)

-   ARM异常处理的具体步骤

    -   将下一条指令的地址存入相应的链接寄存器之中
        -   ARM状态中，LR寄存器保存的是下一条指令的地址（+4/8）
        -   Thumb状态中，当前指令地址偏移一个值后的地址
    -   复制CPSR到SPSR
    -   根据异常类型，强制设置CPSR的运行模式位
    -   将PC设置为中断处理程序向量地址，同时设置中断禁止位

-   ARM异常返回的具体步骤

    -   将LR中的数值减去相应偏移量以后送到PC之中
    -   将SPSR复制回CPSR之中，**将T,F和I位自动恢复为异常发生之前的数值**
    -   清楚中断禁止位

-   异常的类别

    -    未定义指令异常：可以用于在没有物理协处理器的系统上，对协处理器进行软件仿真，或者在软件仿真的时候进行指令扩展。当ARM执行协处理器指令时，它必须等待外部协处理器应答之后，才能真正执行这条指令，如果没有响应信号，就会出现未定义指令异常。

    -    软件中断异常：由**执行`swi`指令产生**，使用该机制可以进行软件仿真，无论出于ARM状态还是Thumb状态，处理器均可以通过执行指令`movs pc,r14_svc`，返回到`swi`指令的下一条指令

    -    中止异常：（取指令、取数据失败）
    
         -    指令预取中止：取指令的地址不存在，或者禁止访问，那么存储器会向处理器发出中止信号。
         
         -    数据中止：处理器数据访问指令的地址不存在，或者该地址不允许数据访问时，会产生数据中止异常。![image-20230626125106000](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230626125106000.png)
         
    -    IRQ异常：正常的中断请求，系统外设可以通过该异常请求中断服务。**触发条件：**CPSR中的`I=0`，且外部中断请求引脚`n_IRQ`有效。
    
    -    FIQ异常：**触发条件：**`n_FIQ`引脚有效
    
         ![image-20230624175902440](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230624175902440.png)
    
    
    






## ARM指令集

**注意：**`{}`寄存器列表（reglist）必须按由小到大排列；无论出栈、入栈的方式如何，永远保持==低地址数据存放在小寄存器中，高地址数据存放在大寄存器之中==。

### ARM指令基本格式

![image-20230625110449927](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625110449927.png)

-   条件码`cond`：所有的ARM指令都可以条件执行，而Thumb指令只有`B`指令才具备条件执行功能

    ![image-20230625110602448](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625110602448.png)

-   是否影响标志位`S`：默认情况下，数据处理指令不影响标志位，但是添加`S`之后会影响标志位。**比较指令不需要添加`S`就可以影响标志位**。

### ARM指令内容

-   分支跳转指令
    -   使用专门的跳转指令——前后32MB寻址空间
    -   向程序计数器写入内容——实现4GB地址空间跳转
    -   数据跳转指令包括三条：`B`,`BL`,`BX`。分别为无条件、子函数调用跳转、状态切换跳转
-   数据处理指令：**由于RISC的特性，ARM只能对寄存器进行操作，无法操作存储器**
    -   数据传送
    -   算术、逻辑运算指令
    -   比较指令
-   存储器访问指令
    -   单寄存器LOAD/STORE指令：`LDR`,`STR`
    -   多寄存器：`LDM`,`STM`. 
    -   寄存器和存储器



## 第四章 嵌入式存储器系统

### 嵌入式存储器的类型

-   按位置分类

    -   主存
    -   外存

-   按存储介质分类

    -   半导体存储器
    -   光盘存储器
    -   磁表面存储器

-   按存储方式

    -   RAM
        -   静态随机存取存储器RAM：速度非常快，但集成度低。一般用于制作Cache
        -   动态随机存取存储器DRAM：速度比SRAM慢一些，但是集成度高，成本低，功耗低。
        -   SDRAM：同步动态随机存取存储器。CPU与RAM共享时钟周期，两者以同样的速度进行工作
        -   DDR SDRAM：允许在时钟的上升沿和下降沿两次传输数据
    -   顺序存取存储器：SAM
    -   直接存取存储器：DAM
    -   只读存储器：ROM
        -   MROM：掩膜只读存储器
        -   PROM：可编程只读存储器
        -   EPROM：可擦写可编程只读存储器
        -   E$^2$PROM：电可擦除可编程只读存储器
    -   闪存：Flash。可以长期保存信息，又可以在线机型快速的擦写，具备ROM和RAM的优点
        -   NorFlash：具备芯片内执行特性。应用程序可以在其中直接运行，无需读取到RAM之中
        -   NAND Flash：极高的存储密度，擦写速度也比较快。

    

    

### 嵌入式存储器系统的结构

![image-20230625113543400](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625113543400.png)

​    

   ### Nor Flash 与 NAND Flash

![image-20230625115833087](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625115833087.png)

使用NAND Flash作为引导ROM的启动流程

![image-20230625120041127](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625120041127.png)



NorFlash

-   读取速度快，写入速度慢
-   程序可以直接在存储器内执行
-   擦写次数约为10万次
-   带有SRAM接口，与微处理器连接方便
-   适用于存储固化的系统引导代码、操作系统代码、应用程序代码
-   通常配置到**Bank0**。当系统上电或者复位之后，从其中或取指令并且执行

NAND Flash

-   擦写速度很快。数据密度高，价格相对较低
-   使用时需要复杂的IO接口电路和存储管理
-   擦写次数为100万次
-   适用于存储大量的用户数据和程序代码
-   支持自启动引导

-   NAND Flash之中相关引脚

    -   存储器选择位NCON
    -   存储器页容量选择位GPG 13
    -   存储器地址周期选择位GPG 14
    -   总线宽度选择位GPG 15

-   两种工作模式

    -   自动引导模式：S3C2440的引脚OM1和OM0均为低电平时，系统处于NAND Flash引导模式

    -   普通闪存模式：支持数据读写擦除操作

        ![image-20230625121242825](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625121242825.png)





## 第五章 常用外围设备以及接口

### 通用输出输入端口GPIO

-   用于连接各类输入、输出设备，实现与微处理器之间的数据传输
-   构成：130个引脚，分为九组：GPA~GPJ。每个端口具有多种功能，需要在主程序运行之前，借助对应的控制寄存器继续变成设置
    -   GPA：23个引脚
        -   用于普通输出口
        -   用于输出外接主存的地址信号和存储块的选择信号，以及外界NAND Flash存储器的控制信号
    -   GPB：11个引脚
        -   普通**输出/输入**端口
        -   用于DMA和总线请求信号和应答信号以及各种时钟信号
    -   GPC：16个引脚
        -   **输入输出**
        -   用于LCD显示器的数据信号和控制信号
    -   GPD：16个引脚
        -   **输入输出**
        -   LCD的数据信号
        -   SPI总线的控制信号
    -   GPE：16个引脚
        -   **输入输出**
        -   用于*SPI，I$^2$C,I$^2$S*总线和SD存储器的控制信号
        -   用于音频接口的控制信号
    -   GPF：8个引脚
        -   **输入输出**
        -   **中断请求信号**
    -   GPG：16引脚
        -   **输入输出**
        -   **中断请求信号**
        -   **SPI总线，LCD显示器**的控制信号
    -   GPH：11个引脚
        -   输入输出引脚
        -   异步串行接口UART的控制信号
        -   异步串行接口UART的控制信号（仅两个）
    -   GPJ:13引脚
        -   **输入输出**
        -   用于摄像头接口的数据信号的控制信号
-   IO端口的控制
    -   端口配置寄存器：GPACON~GPJCON
    -   端口数据寄存器：GPADAT~GPJDAT
    -   端口上拉寄存器：**GPBUP**~GPJUP
    -   驱动能力寄存器：DSC0~DSC1



### 中断系统

1.   中断的作用
     1.   并行处理
     2.   实时处理
     3.   故障处理
     
2.   中断系统的构成
     1.   芯片外部中断请求引脚和内部外设出发**外部中断请求IRQ和快速中断请求FIQ**
     2.   通过使用中断控制器，实现对60个中断源的发出的中断信号的接受与管理
     
3.   一级中断源与二级中断源

4.   中断控制器
     1.   功能
          1.   外部中断请求信号管理
          2.   中断模式设定
          3.   中断请求信号标记
          4.   中断屏蔽设定
          5.   中断优先级管理
          6.   中断服务标记
     
     2.   中断管理功能的实现
     
          1.   17个特殊功能寄存器SFR——6个与一级中断源相关的SFR，2个与二级中断源相关的SFR，与外部中断源相关的SFR 9个
     
               ![image-20230625144002173](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230625144002173.png)
     
          2.   源挂起寄存器——**用于标记32个一级中断源的中断请求信号是否触发**
     
          3.   中断模式寄存器——用于设定32个一级中断源的中断模式。如果设置为1，则相应的中断源按FIQ模式进行处理；否则按IRQ模式处理。同一时刻内，仅有一个中断源可以设置为1.
     
          4.   中断屏蔽寄存器——设置为1，响应中断源被屏蔽；否则可以被响应；
     
          5.   中断判优：中断控制器借助优先级裁决器对32个中断源进行判优
     
               1.   6个一级裁决器
               2.   1个二级裁决器





## 嵌入式Linux系统及其编程



### Bootloader

-   Linux操作系统结构

    ![image-20230626151656663](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230626151656663.png)

-   Bootloader作用

    -   对操作系统的硬件设备进行初始化，将操作系统映像装载到内存之中，并建立内存空间映射图，从而为最终调用操作系统内核准备好正确的软硬件环境。

-   Bootloader运行模式

    -   加载模式
        -   也称自主模式，是Bootloader的**正常工作模式**
        -   运行过程：
            -   准备好操作系统内核需要的环境和参数
            -   从目标机自身的**固态存储设备**将操作系统内恶化加载到RAM之中
            -   运行操作系统内核
    -   下载模式
        -   用于系统测试或者版本修改/升级，目标机上的Boot loader通过串口或者网络，从主机下载文件到RAM中，之后写入到存储设备中

-   Bootloader运行过程

    -   stage1：依赖于体系结构，使用汇编语言实现
        -   硬件设备初始化
        -   准备RAM空间
        -   拷贝stage2到RAM空间之中
        -   设置堆栈
        -   跳转到stage2入口点执行程序
    -   stage2：使用C语言实现，实现更复杂的功能
        -   初始化本阶段所用设备
        -   检测内存映射
        -   读取内核映像和文件系统
        -   为内核设置启动参数
        -   调用内核



### Linux

-   Linux层次划分![image-20230626152600042](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230626152600042.png)

-   内核的作用

    -   应用程序执行流程管理
    -   内存和IO管理
    -   系统调用控制
    -   设备管理

    