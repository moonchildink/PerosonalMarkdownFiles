# 计算机组成原理



## 第一章 计算机系统概论

### 计算机系统概述

**计算机软件**

1. 分类：
    1. 系统软件：操作系统、语言处理程序（翻译程序+Linker,Debug,Loader)
        1. 其中，翻译程序有三种，汇编程序、编译程序、解释程序
    2. 应用软件

**计算机语言**

1. 机器语言
2. 汇编语言
3. 高级语言

**计算机系统的层次结构**

1. 实际机器：由硬件或者固件实现的机器
2. 虚拟机器：以软件为主实现的机器

![image-20230417163022283](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417163022283.png)

**现代计算机结构模型**

![image-20230417163312735](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417163312735.png)



### 计算机性能指标

#### CPI

1. CPI: cycle per instruction.执行一条指令所需要的时钟周期数。

​		计算计算机运行速度的指标：吉普森方法
$$
T_M = \sum^{n}_{i=1} f_it_i \\
其中，T_M表示运行速度，f_i表示指令出现频率，t_i表示该指令运行时间
$$

2. CPI的计算方法
    $$
    t = \sum_{i=1}^{n} CPI_i \times C_i, \quad其中t表示程序运行时间，
    $$
    

#### MIPS

MIPS：Million Instruciton Per Second,每秒执行百万条指令数

由于不同机器指令集不同、不同的指令执行周期不同，所以MIPS不能反应CPU的运行速度。



## 第三章 总线



### 总线标准

1. ISA总线：使用独立于CPU的总线时钟，并行，时钟频率8Mhz，带宽16MBps
2. EISA总线：ISA总线的拓展。并行。带宽33MBps
3. VESA总线：局部总线，能够实现将IO设备挂载到CPU上。
4. PCI总线：串行。高性能、兼容性好、拓展性好



### 总线结构

#### 总线判优控制

总线判优控制分为以下两种：

1. 集中式
    1. 链式查询：
        1. 一共三根线：总线忙线、总线请求、总线同意。
        2. 总线同意信号BG串行地从一个IO接口传输到下一个IO接口。
        3. 距离总线越近的设备优先级别越高
        4. 具有方便扩充设备、对故障敏感的特点。
    2. 计数器定时查询
        1. 相比于链式查询，多了一组设备地址线，但是少了一跟总线同意线。
        2. 优先级别可变。
        3. 控制较为复杂。
    3. 独立请求
        1. 对于N个设备，一共N个请求线与N个总线同意信号线。
        2. 响应速度快，优先次序控制灵活，但是控制线多，控制更为复杂。
2. 分布式

#### 总线通信控制

1. 同步：使用公共时钟，有统一的传输周期。由于需要等待最慢的模块，所以会大大拖累总线的速度。
2. 异步
    1. 无互锁：没有相互制约关系
    2. 半互锁：简单制约关系：总线接待到模块的回答信号之后才撤销请求信号，存在互锁关系。
    3. 全互锁：完全制约关系，主模块发出请求信号之后，必须等待从模块回答信号才撤销请求信号；从模块发出回答信号，必须等待主模块获知后，才撤销回答信号。
3. 半同步控制：在主模块发出读、写信号之后，如果从模块没准备好，那么则添加$\overline{WAIT}$信号之后，
4. 分离式通信：将一个总线传输周期分解为两个子周期，每个子周期可以供不同模块申请，每个模块都可以成为**主模块**。获得控制权的主模块采用同步方式传送，且仅仅在传输命令与数据时占用总线。



**习题**:

1. 控制总线所提供的完整信息为：所有存储器与IO设备的时序信号与控制信号、来自IO设备和存储器的响应信号
2. 计算机使用总线结构的主要优点是便于实现积木化，缺点是两种信息源的代码不能同时在总线中传送
3. 三总线的计算机结构是指：IO总线、主存总线和DMA总线的三组传输线



## 第四章 存储器

### 计算机系统存储器层次结构

1. 计算机系统存储层次可以分为缓存-主存层次与主存-辅存层次。前者主要解决速度问题，后者解决容量问题。

#### 主存

主存的分类：

1. 静态RAM：利用触发器工作原理制成，无需进行刷新，成本较高。多用于制作高速缓存
2. 动态RAM：采用电容原理制成，每2ms需要刷新一次，成本相对较低，多用于存放用户程序。
    1. 刷新方式又可以分为几种：集中刷新（在规定的一个刷新周期内，对全部存储芯片逐行进行刷新。存在死时间）、分散刷新（将存储单元的刷新分散到每个存取周期内完成。不存在死时间，但是会大大降低访存速度）、异步刷新（结合以上两种方式，既可以大大降低死时间，而且对存储器地访问速度没有太大的影响）。
    2. *这一部分可能考察死时间计算问题*
3. ROM
    1. EROM
    2. EPROM

#### ==主存与CPU的连接==

RAM芯片引脚：$\overline{OE},\overline{CE},\overline{WE}$。分别为：读允许，片选线，写允许。

ROM芯片则为:$\overline{PGM},\overline{CE},\overline{OE}$.分别为：编程允许，片选，读允许。

### 提高访存速度的措施

#### 单体多字并行主存系统





### Cache

因为主存的速度无法满足CPU的速度要求，因此，在CPU与主存之间，再增加一级存储结构，成为Cache.Cache由SRAM组成，具备速度极高、容量小等特点。

如图所示的存储三总线结构之中，CPU与Cache交互，而Cache则直接与主存进行交互。实际上，CPU会优先访问Cache，当Cache中不存在所需要的数据时，则会再次访问主存查找。

![image-20230417132855684](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417132855684.png)

#### 概述

1. **理论依据：**程序访问的局部性原理
2. Cache的工作原理：
3. Cache命中率的计算：

$$
h = \frac{N_c}{N_c+N_m} 
$$

4. Cache的读写操作：

    ![image-20230417133316315](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417133316315.png)

#### Cache映射

Cache映射的三种方式：

1. 直接

    1. 将主存的每一块映射到Cache中的一个固定的行的方式。
    2. 映射公式为：$i = j \quad mod \quad C$
    3. 每个缓存块可以与若干个主存块映射，而每个主存块只能与一个缓存块对应。每个Cache行中，标记为1表示该字块有效，否则无效。

    ![image-20230417134332207](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417134332207.png)

    4. 特点：容易实现，无需考虑替换问题。不够灵活，命中率低。

2. 全相联映像(fully associative)

    1. 主存之中的任意一块可以映射到缓存之中的任意一块。
    2. 分配主存地址时，只需要计算字块内地址。剩下的全部为主存字块标记。

    ![image-20230417135118322](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417135118322.png)

3. **组相联映射（Set Associative)**

    1. 将存储空间分为若干组，主存块与cache组之间直接映射，而与组内各块之间则是全相联映射。

    2. 主存地址分配

        ![image-20230417145235283](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230417145235283.png)
        $$
        字块内地址:b \\
        组地址: q = c-r \\
        主存字块标记: s = t+r \\
        $$
        其中，有$2^q = \frac{2^c}{2^r},即q = c -r$.

        







## 第六章

### 1. 数的表示

1. 补码

**整数：**
$$
[x]_{补} = 
\begin{cases}
0,x \quad 2^n > x \ge 0 \\
2^{n+1}+x\quad 0>x \ge -2^n (mod\ 2^{n+1})
\end{cases} \\
其中，x为真值，n为整数的位数
$$
**小数：**
$$
[x]_补 = 
\begin{cases}
x \qquad 1>x \ge 0 \\
2+x \qquad 0>x \ge -1(mod \ 2)
\end{cases} \\
x为真值
$$
![image-20230418115346778](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230418115346778.png)

注意，当补码的位数不同时，同一数字的补码也会不同。

比如，对于$[-2^{n-1}]$，当补码的位数为n时，$[-2^{n-1}]_{补}\ =\ 2^n - 2^{n-1}\ =\ 10...0$。当**补码的位数为n+1**时，模为$2^{n+1}$，$[-2^{n-1}]_补\ = \ 2^{n+1}-2^{n-1}\ =\ 10...0 （n+1）位$

![image-20230418121414160](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230418121414160.png)

原码 第一位代表符号位，其余七位数字按照无符号数转换为十进制即可。而反码需要除第一位以外，全部取反，所得便是真值。原码和反码都存在$\pm 0$。

而对于补码而言，可以将数值位取反加一（保留溢出），得到数值部分，结合符号位便得到原真值表示。

2. 移码表示方法

$$
[x]_{移} = 2^n+x \qquad (2^n>x \ge -2^n)
$$







## 第五章 输入输出系统

### 概述

1. IO系统的发展

    1. 早期：分散连接，程序查询方式，CPU与IO接口**串行**工作
    2. 接口模块与DMA阶段：CPU与IO**并行**工作，IO通过接口与主机交换信息
    3. 通道结构
    4. IO处理机：简称IOP，该方式有自己的指令系统，可以实现独立于CPU的IO操作

2. IO系统的组成（软件）

    1. IO指令：有操作码、命令码与设备码三部分组成
    2. 通道指令：指出数据组的首地址、字数或末地址、操作命令

3. IO系统的组成（硬件）

4. IO与主机进行通信的控制方式

    1. 程序查询方式：适用于低速设备，用程序完成主机与外设之间的通信，使用**串行**工作方式

    2. 程序中断方式：CPU可以与外围设备**并行**工作，数据的出入经过CPU，一般用来连接低速设备

    3. DMA方式：

        1. 直接存储器存取，使用硬件在主存与设备之间进行数据传送，在数据传送期间不需要CPU程序干预。
        2. 主存与IO之间有一条直接数据通路，占用主存周期进行数据传送

        ![image-20230509123025263](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230509123025263.png)

![image-20230509123244968](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230509123244968.png)



### IO接口

1. IO设备的分类：

