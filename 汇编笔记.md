# 汇编笔记

 

### 大纲

1. BCD码
    1. 压缩BCD码：使用四位二进制来表示以为BCD码。
    2. 非压缩BCD码：将8位二进制的高四位指令，仅仅使用低四位来表达一位BCD码，则被称为非压缩BCD码。



### debug之中的主要命令

+ `r`查看，改变CPU寄存器值中的内容

+ `d`查看内存之中的内容

+ `e`修改内存之中的内容

    



### 第一次实验



0. 找到dosbox所安装的地址，打开dosbox程序

1. 打开debug程序，使用了`r`命令查看初始寄存器之中的内容

![image-20230120151105712](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151105712.png)

2. 使用`a`命令在`cs:ip`位置输入汇编代码
3. 使用`u`查看刚刚输入的汇编代码所对应的机器码

![image-20230120151123691](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151123691.png)

4. 在程序未执行以前，使用`d`命令查看内存之中的内容

![image-20230120151132052](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151132052.png)

5. 执行命令，分别查看寄存器之中的内容和内存之中的内容

![image-20230120151136684](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151136684.png)





**注：**似乎因为0200~020b之中初始数值为0，导致执行了编译命令以后较原来的没有区别。稍后尝试一下在初始时便修改0200到020B区间的内容。



1. 使用`e`命令修改200到20b区间的内容

![image-20230120151141988](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151141988.png)

2. 输入汇编指令执行

![image-20230120151145314](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151145314.png)

3. 执行指令

![image-20230120151156007](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151156007.png)

![image-20230120151150038](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151150038.png)

3. 查看寄存器之中的内容

![image-20230120151204581](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151204581.png)

4. 查看0200到020b区间的内容

![image-20230120124728380](C:\Users\29236\AppData\Roaming\Typora\typora-user-images\image-20230120124728380.png)







### 《汇编语言》王爽P45页习题

1. 输入指令

![image-20230120151213146](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151213146.png)

2. 执行命令

![image-20230120151219864](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151219864.png)

![image-20230120151228381](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230120151228381.png)













### 王爽P74实验

![image-20230123110807111](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123110807111.png)

输入汇编代码，查看`ffff:0 f`区间的内容，发现是主板ROM上存储的生产日期。

之后逐步执行，查看结果：

![image-20230123111143251](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123111143251.png)

*注意此步：由于ax的长度为十六位，两字节，所以执行`mov ax,[0]`时，要移入两字节的内容。但是，由于在内存之中一个字地位存储在内存低位，高位存储在内存高位。所以，`ax`之中，`(ah) = C0,(al) = ea`*

![image-20230123111636676](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123111636676.png)

执行`push ax,push bx`之后，可以发现栈顶指针`sp`减小了2*2.

![image-20230123111753001](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123111753001.png)

执行`pop ax,pop bx`之后，`ax bx`交换了数值。

![image-20230123111941202](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123111941202.png)







### 快捷编译，链接汇编程序

1. 创建`.asm`汇编程序源文件
2. 执行DOSbox，挂载c盘到masm以及link所在的文件夹
3. 编译：`masm c:test;`.**注意：1.最后的分号  2.由于将c盘挂载到了debug目录之下，将根地址更改为c：即可。**

![image-20230123182756338](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123182756338.png)

5. 连接：`link test;`

![image-20230123182837054](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123182837054.png)

6. debug:`debug test.exe`

![image-20230123183040559](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123183040559.png)

**注意：**

1. 此时`cs,ip`以及各个寄存器已经指向程序所在地址,同时注意下一条要执行的指令便是我们所写的程序.
2. 使用`u`命令查看代码:段地址便是`cs`所在地址

![image-20230123183338181](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123183338181.png)

3. 使用`t`命令执行每一行代码,==**注意最后一行的`int 21h`必须使用`p`命令执行**==

![image-20230123183615703](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123183615703.png)







### 王爽P94页实验

1. 查看PSP之中的内容:以`CD 20`开头

![](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123185234617.png)

2. 执行程序

![image-20230123185518796](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123185518796.png)

似乎在进行编译的时候,如果数字后边不加`h`会认为是十进制.此处`(SP) == 0Ah`.

![image-20230123185741135](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123185741135.png)

继续执行,似乎出现了栈溢出.







### 王爽P97页实验

1. 输入程序

![image-20230123191329958](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123191329958.png)

2. 逐步执行,查看结果

![image-20230123191442013](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123191442013.png)

可以发现:**`[bx]`指令的含义是:获取`(ds*16+bx)`处的内存**

![image-20230123191634450](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230123191634450.png)





### loop指令

1. 使用标号来表示实际上要跳转的地址.在DOS之中,标号实际上表示要跳转执行程序行的地址.
2. 使用`g`命令可以执行到指定位置.比如,`g 1012`表示一直执行到1012地址
3. 使用`p`命令可以跳过重复的loop过程

#### loop实验：P121

```assembly
;1. 向内存0:200~0:23f依次传送数据0~63、
```

```assembly
;2. 使用九条指令完成第一题
```

```assembly
;3. 调试给出的程序，跟踪运行成果
```







### 具有多个段的程序

#### 王爽P134页实验1

```assembly
assume cs:code,ds:data,ss:stack

data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0
stack ends

code segment

start:
    mov ax,stack
    mov ss,ax
    mov sp,16

    mov ax,data
    mov ds,ax

    push ds:[0]
    push ds:[2]
    pop ds:[2]
    pop ds:[0]

    mov ax,4c00h
    int 21h

code ends

end start
```

![image-20230124112202117](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230124112202117.png)

1. `(ds = x)`,则`(ss) = x+1,(cs) = x+2`







#### 实验二

```assembly
assume cs:code,ds:data,ss:stack

data segment
    dw 0123h,0456h
data ends

stack segment
    dw 0,0
stack ends

code segment

start:
    mov ax,stack
    mov ss,ax
    mov sp,16      ;按理说sp = 4即可，不知道为什么要开辟这么大的栈空间

    mov ax,data
    mov ds,ax

    push ds:[0]
    push ds:[2]

    pop ds:[2]
    pop ds:[0]

    mov ax,4c00h
    int 21h

code ends
end start
```

![image-20230124113354845](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230124113354845.png)

查看汇编指令,执行.









### JMP指令

#### P187页实验

```assembly
assume cs:codesg

codesg segment

    mov ax,4c00h
    int 21h

start:
    mov ax,0
s:  nop
    nop

    mov di,offset s
    mov si,offset s2
    mov ax,cs:[si]
    mov cs:[di],ax
s0: jmp short s

s1: mov ax,0
    int 21h
    mov ax,0

s2: jmp short s1
    nop

codesg ends
end start
```

在debug之中查看编译后的代码

![image-20230126112251619](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230126112251619.png)

执行了`mov cs:[di],ax`之后，`(cs:0008 = EBF6)`，向前跳转8位。在标号S2处，向前跳转8位为`s1`的地址，而在地址0008处，向前跳转8位的地址为0000

![image-20230126113549663](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230126113549663.png)





#### P196

```assembly
assume cs:code

data segment
    dw 8 dup(0)
data ends

code segment
start:
    mov ax,data
    mov ss,ax
    MOV sp,16
    mov word ptr ss:[0],offset s
    mov ss:[2],cs
    call dword ptr ss:[0]
    nop

s:
    mov ax,offset s
    sub ax,ss:[0ch]
    mov bx,cs
    sub bx,ss:[0eh]
    mov ax,4c00h
    int 21h
code ends
end start
```

![image-20230126122642059](https://cdn.jsdelivr.net/gh/moonchildink/image@main/imgs/image-20230126122642059.png)





#### P293页程序

